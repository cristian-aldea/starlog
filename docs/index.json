[{"content":"When I visited my grandma, she shared her tips for living a long and healthy life, and I wanted to share them here! Below is a picture of her tips:\nHere is a transcript. Clarification notes are provided in square brackets [].\nFor a long life\nTips\n10,000 steps a day Master [your own] time Train your mind (learn something new) Be curious Laugh Avoid excess kilograms (BMI max 30) Lose weight but don\u0026rsquo;t die [Don\u0026rsquo;t torture yourself with diets] Eat a bit of everything [have a varied diet] No alcohol Eat whole-grain bread Measure blood sugar and blood pressure often Help your memony with notes [reminders] No sugar, and have fruit Be sociable Avoid dust, noise and poisons Mandatory medical check-ups Three meals a day at fixed times Sleep deeply Cultivate focus [mindfulness], breathe deeply Do what you love! Any pain is alarming Praise God, Hallelujah\n","permalink":"https://blog.cristianaldea.com/posts/2024/grandmas-tips/","summary":"I share a little wisdom from my grandma.","title":"Grandma's Tips"},{"content":"I got the opportunity to move to Vancouver when I started my new position as a Software Development Engineer at Amazon in Summer 2022. I had been living with family beforehand and had little experience with moving. I learned a lot while going through the process, and I wanted to share my experience in case it helps anyone.\nTiming When planning the relocation, I first had to settle on when I\u0026rsquo;d move. I was looking for a time that would work best. Generally, the time of year can play a factor:\n‚òÄÔ∏èSummer can be a busy season for moves and rent might be a bit higher, especially during back to school around August-September ‚ùÑÔ∏èWinter isn\u0026rsquo;t very busy, but the weather can be rough depending on where you\u0026rsquo;re moving to üçÇFall seemed like a good fit, so I planned my travel for Fall 2022.\nTransportation After picking a date, I had to consider transportation. I chose to fly to Vancouver since I didn\u0026rsquo;t own a car and didn\u0026rsquo;t want to take the train. But it\u0026rsquo;ll depend on your preferences.\nDon\u0026rsquo;t forget to take advantage of any relocation benefits you might have with your employer. You might be able to expense the transportation, movers or temporary accommodations you used for your move.\nResidence After arriving in Vancouver, I booked some short-term accommodations while I went looking for a place to rent, this worked out well for me:\n‚úÖ I got to experience the city and visit neighbourhoods before picking a place ‚úÖ You can avoid scams much more easily by dealing with people in person ‚ùå I had to move my stuff twice. I packed lightly so this wasn\u0026rsquo;t a big issue A few tips related to renting I picked up were:\nDon\u0026rsquo;t ever send payments to someone without first seeing the home and signing a tenancy agreement. Places like Craigslist have a great set of guidelines to help keep you safe: https://www.craigslist.org/about/scams. When signing a lease agreement, double-check that it\u0026rsquo;s the official form by visiting your local government website. Here\u0026rsquo;s an example for Vancouver, BC: Link Take advantage of any relocation benefits you might have with your employer to help with the financial burden Luggage and Stuff I initially packed just the necessities to help with moving, and then shipped or brought over things over time as I settled into the new place I was renting long-term.\nUpdating all your services Once I had a new address, I had to update my home address to a bunch of services:\nüè¢ my employer üçÅ the government (provincial and federal) üè¶ banks and other online services I use I also had to book some appointments to get ID and documentation as a BC resident. If you\u0026rsquo;re moving somewhere you\u0026rsquo;ll likely be able to find resources on the matter, such as Moving to British Columbia from within Canada.\nAdjusting to the new City My first weeks in Vancouver were busy and exciting. A few months in, after I settled into a routine, I was happy to have the time to explore the city, but at the same time, I felt a bit off being far away from home.\nWhen I started feeling homesick, I\u0026rsquo;d stay in touch with friends and family online, and explore what Vancouver had to offer: hikes, running, and much more!\nThanks for reading! If you have any feedback, share it on social media or by using the \u0026ldquo;Leave Feedback\u0026rdquo; above.\n","permalink":"https://blog.cristianaldea.com/posts/2024/how-i-moved-across-canada/","summary":"I go over the process for my relocation to Vancouver.","title":"How I Moved Across Canada"},{"content":"VoteIt is a voting app I made. It\u0026rsquo;s not a new concept, but I had ideas for a few features that I thought would bring a lot of value:\nYou don\u0026rsquo;t need to sign up You don\u0026rsquo;t get bombarded with ads You get the option of Ranked Voting! This let\u0026rsquo;s you express preference between option (1st choice, 2nd choice, etc.) and isn\u0026rsquo;t something I\u0026rsquo;ve seen online yet. Before VoteIt, I never built a full-stack application on my own. Now that I\u0026rsquo;ve completed the project, I see a lot of things which I wish I knew, and certain things I wish I did differently.\nIn this blog post, I wanted to explain the lessons I\u0026rsquo;ve learned from building VoteIt, and hopefully it\u0026rsquo;ll help you in your next project!\nTechnology Stack An important choice is the technologies you\u0026rsquo;ll use in your project. This isn\u0026rsquo;t always an easy choice, as your project might have unique requirements, or you might be more familiar with specific tools.\nFor anyone curious, here\u0026rsquo;s the stack I went with in my project:\nFor the front-end, I wanted something reliable and popular, so I went with React, since For the back-end, I wanted something fast, minimal, and easy to maintain. I built an http API using Golang and Fiber. Finally, for the database, the data types I had to deal with were simple, and so wanted something simple and unstructured (NoSQL). A popular choice was MongoDB, so I went with that. These decisions ended up having a big impact on my project. And if I had the chance to start the project all over again, I would have taken more time to research my options in this phase.\nDependencies One danger to consider is over-enginerring your project. Fireship had a great video on this subject:\nIt was helpful for me, and for the long term health of the project, to be very conservative when adding new dependencies to VoteIt. When I say \u0026ldquo;dependency\u0026rdquo; I mean any packages or libraries that weren\u0026rsquo;t made by me. If it wasn\u0026rsquo;t a hassle to implement a feature, I probably did it myself.\nAdding dependencies can speed up development, but can also have downsides if you\u0026rsquo;re not careful of the quality of the code you\u0026rsquo;re bringing into your project:\nIt might get abandoned by it\u0026rsquo;s maintainer, leaving the project dead with issues that won\u0026rsquo;t get fixed It might contain bugs or security issues which are hard to work around It might make other dependencies you\u0026rsquo;d want to add incompatible or complicate your project or build process You shouldn\u0026rsquo;t completely avoid all dependencies for your project, but the fewer you have the easier it will be to maintain them.\nPrioritization When I was working on this personal project, I didn\u0026rsquo;t have deadlines or expectations. This was something that made the development of VoteIt slower than it needed to be. I\u0026rsquo;d work on problems or refactors that didn\u0026rsquo;t affect the functionality much, instead of focusing on the experience I wanted for the end user.\nWhat helped me push through these bad habits was keeping in mind focused on why I was making VoteIt: to have an easy and reliable way to get decisions done in a group. Also, I kept reminding myself that there\u0026rsquo;s always a \u0026ldquo;better\u0026rdquo; way to do something in software engineering. An important skill to learn is knowing when the code is \u0026ldquo;good enough\u0026rdquo;, and can satisfy the requirements you have.\nIntegration hell An issue that only comes up well into development is integration. I feel like a lot of incomplete project stop at this stage. Once you\u0026rsquo;ve built parts of your application, getting them to work together isn\u0026rsquo;t always easy. Also, some issues don\u0026rsquo;t surface until the final steps of development. These issues might be unique to your project and hard to troubleshoot, but they are a normal part of development and nothing to worry about.\nSome examples issues I ran into for my project were:\nform and input validation was much more involved than I expected, due to the many kinds of ways users could input votes drag and drop was a nightmare to try and implement, since the web APIs for it aren\u0026rsquo;t very refined. I ended up using a library which lead to a lot of troubleshooting of new issues that came up. Shoutout to atlassian/react-beautiful-dnd üôè, an amazing project. reliably testing my websocket implementation was hard due to the many rules of the system I built. New issues could come up that I didn\u0026rsquo;t account for which ate up a lot of time to fix. StuffMadeHere talk about this phenomenon in many of his projects. Accepting it as a normal part of engineering and persisting through them is how projects get done.\nDeployment Once you\u0026rsquo;ve developed the app, you\u0026rsquo;ll need to find some way to deliver it to your users. This depends on the platform you\u0026rsquo;re developing for. Websites usually need a server, mobile apps can be published on the app store, and games can be distributed with a storefront like Steam.\nI had to setup some way for people to see my website. I learned a lot about how webservers work by going through the process of creating my own from stratch: configuring the VPS, setting up the OS, setting up networking, and implementing secure connections using HTTPS. I could have gone with a simpler solution, but I was in it for the learning, and I can always change it later.\nThere are many options in this space. If you\u0026rsquo;re not sure where to start and I\u0026rsquo;d recommended going with simple and \u0026ldquo;batteries included\u0026rdquo; solutions like Firebase or AWS Amplify so you can get up and running as soon as possible.\nThe reason why we test Initially, I had no tests for the project, which worked fine since everything was simple at first. As the project grew larger, this started to become an issue. I lost confidence in the code I was writing, sometimes breaking features unknowingly.\nThat\u0026rsquo;s when I naturally gravitated to testing. Tests are an amazing, declarative way to make sure your code does what it should be doing. For anyone curious, my testing setup evolved over time, and ended up being as follows:\nUnit tests for functions that are pure or whose dependencies could be mocked Integration testing for the backend API using Postman End-to-end testing using Cypress for whole application However, it\u0026rsquo;s important to write tests for a good reason, they should be simple, or at least, simpler than the code they\u0026rsquo;re testing. If you\u0026rsquo;re spending hours writing tests for a part of your app that has no business impact, then you\u0026rsquo;re wasting precious hours that could have been spent somewhere else. However, if you don\u0026rsquo;t test the parts of your code that are critical to requirements or security, then you might end up wasting a lot of time troubleshooting bugs or manually testing every time you make a change.\nMaintaining Something I didn\u0026rsquo;t consider when creating VoteIt was maintenance. Once a project is done, it\u0026rsquo;ll likely need some sustained effort to keep it running without issues. You should consider things like server costs, logging and alerting when thinking of how you\u0026rsquo;ll be handling a project in the long-term.\nThanks for reading! If you have any feedback, share it on social media or by using the \u0026ldquo;Leave Feedback\u0026rdquo; above.\n","permalink":"https://blog.cristianaldea.com/posts/2022/lessons-from-voteit/","summary":"Sharing what I learned from developing VoteIt!","title":"Lessons From Voteit"},{"content":"Programming is hard work. Having the right operating system (OS) can lead to less hassle, and less time wasted on troubleshooting problems.\nI have used Windows, Linux and macOS extensively for both programming and day-to-day use. Although you can develop software on any platform, each has its pros and cons. In this article, I\u0026rsquo;ll outline these differences, and help you find the right fit for you.\nWhat I write here is based on my experience, and some things might not apply to you. Feel free to use my advice to inform your decision, and pick whatever feels right.\nWindows Windows is the OS I\u0026rsquo;m most familiar with. I\u0026rsquo;ve used it for years, all the way back from Windows XP. It\u0026rsquo;s currently the most popular desktop OS, and supports a wide variety of hardware configurations.\nHowever, I don\u0026rsquo;t like programming on Windows. Unless you want to program games, or you only want to develop Windows apps, you are better off choosing something else.\nNot Unix Most of the public server infrastructure in the world runs on Unix. This includes everything from the servers hosting the most popular websites, to the biggest supercomputers in the world. This makes Unix, which Linux and macOS are based on, a very important platform to learn, especially for web developers. Windows, on the other hand, is based on DOS. This means that Windows is fundamentally different from Linux or macOS, especially for software development.\nOne big difference between Windows and Unix is the shell. A shell is a command-line interpreter (CLI); it\u0026rsquo;s a way for you to talk to a computer by writing text. It\u0026rsquo;s a vital tool for many professional developers. Popular Unix shells like bash and zsh are industry standard, and are used in many companies and projects. Learning Unix can be very valuable for your career.\nWindows, on the other hand, doesn\u0026rsquo;t offer a Unix shell. Instead, it has the Command Prompt program, and the newer Powershell. They get the job done, but are very different from Unix shells, and don\u0026rsquo;t see much use outside of Windows.\nInstalling software is messy As of publishing this article, installing software on Windows has always been an annoying process for me.\nWant Python? go to their website, download an installer, run it, and then follow a bunch of steps to complete the installation.\nWant NodeJS, MySQL or Java? Download another installer, and follow different steps to get the software installed.\nCareful when going through those steps! The installer might not set up your PATH correctly, and now you can\u0026rsquo;t run your program since the system doesn\u0026rsquo;t know where it was installed.\nOn Linux and macOS, installing software is often much simpler.\nOn Linux, a \u0026ldquo;package manager\u0026rdquo; is often included. It\u0026rsquo;s a handy program to install software from official sources by writing a command, or pressing a button. For example, on Debian systems, you can use apt:\napt install python Now you have python installed. Do you want to install anything else? It\u0026rsquo;s all one step away.\nOn macOS, no package manager is available out of the box. However, Brew is a popular third-party offering. Although slow, it\u0026rsquo;s reliable and simple to use:\nbrew install python There are third-party package managers for Windows, like Chocolatey. However, I can\u0026rsquo;t recommend Chocolatey. From briefly trying it, choco doesn\u0026rsquo;t feel as refined or easy to use as brew or apt, since it is maintained by a much smaller community.\nUPDATE: Windows has improved massively in this area in the last few years. As of writing this, winget-cli is offered as the official package manager for Windows. Check it out if you\u0026rsquo;re interested.\nLinux I think Linux is one of the best platforms for learning to code as of writing this article.\nPopular products like MySQL, MongoDB, Java, NodeJS, C++, Docker, Kubernetes, Apache Server, Nginx, Ruby, etc. all have Linux as their main platform. if there\u0026rsquo;s a server running important software, that software is probably running on Linux. This makes it the ideal OS for learning to code, since learning Linux will help you when you will be deploying professional applications to your clients.\nLinux is typically faster than Windows, since it has a lower overhead. It\u0026rsquo;s also free and open-source, making it easy for anyone to get a copy of Linux and get started.\nHowever, despite Linux being used a lot for servers, it\u0026rsquo;s a poor choice for a personal computer. The community using Linux as their main OS is very small and fragmented, and software support for basic things (Adobe, Microsoft Office, OneDrive, video games, etc.) can be lacking.\nAlso, most personal computers either have Windows or macOS installed. Using Linux on your computer will probably require you to install it yourself, which isn\u0026rsquo;t something most people should have to do to use a computer.\nLinus Tech Tips made a very entertaining series detailing their journey of trying to use Linux on their main computer. Watch the first episode linked below:\nRunning Linux alongside another OS Despite the issues with running Linux, it can still be worth playing around with. An easy way to try it is to install it alongside another OS. This way, you get to learn to use Linux, and still have access to something more usable.\nVirtual Machine An easy way to try Linux is to run it on a virtual machine (VM). This allows you to try Linux in its own isolated space, without affecting your current machine in any way. You can then safely remove the VM if you don\u0026rsquo;t need it anymore.\nHowever, VMs are slow, and force you to split resources between your host and your VM. It\u0026rsquo;s not the best long-term solution.\nWindows Subsystem for Linux (WSL) This option, exclusive to Windows, allows you to install Linux and run it alongside Windows. WSL has good integration with many popular tools (VSCode, Jetbrains IDEs, etc\u0026hellip;), and can be removed if you don\u0026rsquo;t need it anymore, just like with a VM.\nI think this is a great option for web development and any application development that isn\u0026rsquo;t graphical. It makes Windows a powerful option for developers.\nHowever, WSL runs Linux in a way that I\u0026rsquo;d describe as \u0026ldquo;headless\u0026rdquo;. There is no Linux \u0026ldquo;GUI\u0026rdquo; you can access to run your Linux programs. The only way you can talk with the Linux subsystem is through a CLI, through networking, or through the file system. This makes things like OpenGL or game development impractical (or impossible) on WSL.\nSee the official documentation if you\u0026rsquo;re using Windows and want to get started with WSL.\nAlso, see this video by Fireship for a nice summary of what WSL can offer:\nDual Boot With Dual Boot, you install two or more operating systems on separate parts of your computer\u0026rsquo;s storage, and you can boot into either of them. You can then run multiple operating systems on one machine.\nThis gives you the most uncompromised way to run Linux alongside another OS, without virtualization or splitting resources.\nHowever, you are splitting your storage into two (or more) pieces. I would not recommend doing this unless you know what you are doing, and I won\u0026rsquo;t be linking any guides to this. You should do your own research. Dual-booting can be dangerous, and you could lose all of your files (make a backup!). Also, an operating system usually doesn\u0026rsquo;t expect itself to be running in dual-boot. When I was dual-booting Windows and Linux, I wasted countless hours running into issues that required me to tinker and waste time maintaining my system.\nmacOS If you want good quality and minimal hassle, Apple products are a good option.\nmacOS is stable, very fast, Unix-based, and requires minimal tinkering to get started. This is because Apple controls every aspect of the machine (hardware, os, software), and can ensure a level of quality that would otherwise be impossible. It\u0026rsquo;s also the only OS where you can develop software for Apple devices, like iOS and Mac. These are big platforms that you shouldn\u0026rsquo;t ignore when you\u0026rsquo;re trying to launch a product.\nHowever, for all these perks, you pay a price. Apple devices are expensive. A Mac will cost you much more than a Windows or Linux machine with equivalent power. Also, Apple products tend to be locked down and hard to repair or upgrade, which is something that matters to many people.\nSummary Here is a summary of the pros and cons of each OS according to my experience, for easy reference.\nSince no option is perfect, I\u0026rsquo;d recommend trying them all and having access to as many of them as you can. Having access to all three operating systems means you can leverage all of their strengths, and avoid all their weaknesses.\nI hope you\u0026rsquo;ve enjoyed reading this, and that you\u0026rsquo;ll find my tips useful in finding the right OS for you :)\nWindows Pros the most popular desktop OS if using WSL, Windows is a very powerful option for web development and non-graphical app development a very good option for developing games or Windows apps Cons not Unix-based installing software can be a pain slower than Linux Linux Pros Unix-based most developer software is made to run on Linux servers a great platform to learn and tinker in can easily be installed alongside other operating systems free (and open-source üëÄ) Cons Poor user experience on personal computers requires a lot more tinkering than other options to get things working macOS Pros Unix-based very stable and fast OS minimal hassle and tinkering, things often work out of the box Cons Apple machines are expensive üí∏ Appl machines tend to be hard to repair and upgrade no native package manager, you need to install something like Brew My Current Setup You might be curious to know what my current setup is. It\u0026rsquo;s subject to change, but here\u0026rsquo;s what I\u0026rsquo;m currently using (since my last update to this article):\nI have a PC with Windows 11 and WSL, which has been working very well for web development I avoid using Powershell or the Command Prompt if I can, and thankfully WSL lets me do that :D I use a MacBook for application development. Anything that has to do with native and graphical apps is a hassle in WSL, and Visual Studio is such a heavy app that I\u0026rsquo;d rather just use my MacBook. ","permalink":"https://blog.cristianaldea.com/posts/2021/best-os-programming/","summary":"A comparison of the most popular operating systems, to help you find the best one for you.","title":"The best operating system for programming"},{"content":"When I decided to create a blog, I knew I needed a static site generator. While researching, I found many popular options listed on websites like jamstack.org, and narrowed down my choices to GatsbyJS or Hugo.\nI ended up going with Hugo for now, and this post will explain why. If you\u0026rsquo;re also looking to start a blog, use the information below to inform your decision, and pick whatever is the best fit for you.\nFaster Build Times First, my biggest issue with Gatsby was the build times. Builds with Hugo are much faster than with Gatsby, which helps with the development experience.\nBuild Time Comparison To be precise, I did some benchmarks of the build times between Hugo and Gatsby (taken from the logs), and summarized everything in the table below. I compared the following projects:\nStarlog: created with Hugo, with two posts and a theme Blank Gatsby: a Gatsby project created using npm init gatsby, with no posts Gatsby blog starter: a Gatsby project using the official Gatsby blog starter, with no posts Metric Starlog Blank Gatsby Gatsby blog starter Initial development build 0.037s 13.156s 14.622s Rebuild on code change 0.008s 0.197s 0.293s Production build 0.061s 23.967s 31.349s The difference is substantial. With Hugo, the builds felt instantaneous, while with Gatsby, the builds felt much slower.\nHowever, the biggest pain point was Gatsby\u0026rsquo;s rebuilds on code changes. Despite what the logs say, it felt like it took a second or two for me to see the changes in the browser after making changes in Gatsby.\nKeep in mind that the Gatsby build times were for projects with no posts. As you add plugins and posts the build time can get much longer.\nWhy is Hugo faster? There are two main reasons why Hugo\u0026rsquo;s builds are considerably faster:\nGolang vs JavaScript (JS) Hugo is implemented in Golang and compiled into a binary Gatsby is implemented in JavaScript. JavaScript isn\u0026rsquo;t compiled1 and is dynamically typed, which typically leads to slower code Templating vs React Hugo uses Golang templating, which uses simple rules and constructs, and is processed very quickly Gatsby runs the React library to generate the DOM tree for every page and then renders each tree into static HTML, which is a much more complicated and lengthy process Overkill This is something I will explore in more detail in a future post. For now, you need to understand that each tool has its use.\nGatsby is a clever framework with a lot of cool features:\nit uses React, which makes it easy to develop dynamic applications through declarative code it pre-renders your pages, to improve performance and Search Engine Optimization (SEO) it \u0026ldquo;hydrates\u0026rdquo; your pages, keeping them dynamic as if it was a regular React app It blends the best of both worlds, keeping the performance of a static website, while allowing for the dynamic rendering of a single-page application.\nHowever, my blog will be serving mostly static content, and wouldn\u0026rsquo;t benefit much from the strengths of React or Gatsby. It would however be much slower and bloated than it needs to be.\nnpm Bloat Using Gatsby and npm leads to a lot of bloat. From my experience, npm projects are hard to maintain. You rely on countless packages maintained by thousands of contributors. When you revisit an npm project after a while, you\u0026rsquo;ll often find that your dependencies are outdated or abandoned, and updating them can lead to a lot of frustration, especially if the project was abandoned.\nnpm has matured a lot, but is still very volatile. I wanted to minimize how many dependencies I had for this simple project. With Hugo, all I needed was the Hugo CLI and a theme, which just requires me to copy some files around.\nA lot of JavaScript Gatsby applications need a lot of JavaScript to work, since React relies on a client-side JavaScript runtime to keep the pages dynamic.\nThe table below outlines the HTML and JS content for each of the projects listed earlier, using the following command:\n# for html find public/ -type f -name \u0026#39;*.html\u0026#39; -exec du -ch -B KB {} + # for js find public/ -type f -name \u0026#39;*.js\u0026#39; -exec du -ch -B KB {} + Metric Starlog Blank Gatsby Gatsby blog starter HTML Content 152kB 17kB 201kB JS Content 123kB 283kB 345kB Total Website Size 459kB 1139kB 3597kB Hugo mostly outputs HTML code. The JavaScript code is from the code block highlighting support, and can easily be removed.\nAlthough JavaScript is very powerful and flexible, it\u0026rsquo;s also the most expensive thing to ship to the browser. Every byte of JavaScript you send to a browser takes much more time and energy to process than HTML or CSS, which are simple to parse and execute.\nIf you don\u0026rsquo;t need your app to be very dynamic, then you don\u0026rsquo;t need a lot of JavaScript. This will lead to your websites being slimmer and faster than they possibly could be with a framework like React or Angular.\nThe Vanilla JavaScript Podcast has a lot of nice episodes explaining the issue I\u0026rsquo;ve described with JavaScript if you want to learn more.\nA few episodes I liked:\nhttps://vanillajspodcast.com/the-developer-experience-is-bullshit https://vanillajspodcast.com/how-i-structure-my-vanilla-js-projects (My projects used to be based on this template! It\u0026rsquo;s very good) https://vanillajspodcast.com/the-web-is-getting-slower Simplicity I was already very familiar with JavaScript, npm, and React when I decided to create Starlog. Gatsby would have been a good fit considering my skills. Hugo, on the other hand, has a templating engine that I didn\u0026rsquo;t know very well.\nDespite this, I found that learning Hugo was easier for me than learning Gatsby, due to how much more complicated the Gatsby ecosystem is, with the seemingly endless choices it offers in terms of plugins and configuration.\nSelf-congratulating While researching the pros and cons of Hugo and Gatsby, something that annoyed me was an article from Gatsby comparing JAMstack technologies.\nThe review article has an obvious conflict of interest, since it\u0026rsquo;s published and controlled by Gatsby. Also, the article wasn\u0026rsquo;t very useful to me because:\nthey compare the products on very generic criteria, without explaining how they reached the scores they got they list very few losing comparisons for Gatsby, making it seem like the perfect solution in all situations (which isn\u0026rsquo;t the case) they claim that Hugo has poor \u0026ldquo;Modern JavaScript syntax\u0026rdquo; support, which is strange. Hugo has long supported ESBuild, which allows you to bundle and transpile your JavaScript code to keep it compatible with older browsers they list redundant points, such as having excellent \u0026ldquo;Componentization\u0026rdquo;, \u0026ldquo;Component libraries\u0026rdquo; and \u0026ldquo;Component ecosystem\u0026rdquo;. Well organizing your code and using templates, you can also achieve good reuse of code through Hugo, so this isn\u0026rsquo;t very useful. they add \u0026ldquo;Swag store\u0026rdquo; as one of the upsides of Gatsby. Why is this here? I thought we were comparing frameworks here! ü§£ This doesn\u0026rsquo;t affect my appreciation of Gatsby as a project, but it did put a dent in my impression of the company.\nConclusion Although Gatsby is a great project, I didn\u0026rsquo;t think it was a good fit for me. I wasn\u0026rsquo;t going to leverage its strengths, and its downsides were too annoying to me.\nIf you feel like the downsides I listed wouldn\u0026rsquo;t be a deal-breaker for you, feel free to pick up Gatsby, I had a lot of fun while trying it out.\nFor now, I\u0026rsquo;ll be using Hugo. But that might very well change in the future.\nReferences https://css-tricks.com/comparing-static-site-generator-build-times/ JavasScript runs on the V8 JavaScript Engine. It\u0026rsquo;s not strictly \u0026ldquo;interpreted\u0026rdquo;, since the engine does a lot of clever tricks to speed up JavaScript execution (although it\u0026rsquo;s still slower than a compiled, statically-typed language like Go). For more details see this post I found on the subject.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://blog.cristianaldea.com/posts/2021/hugo-vs-gatsbyjs/","summary":"I\u0026rsquo;ll explain my reasoning behind choosing Hugo for my blog over GatsbyJS.","title":"Hugo vs. GatsbyJS"},{"content":"Hello!\nWelcome to Starlog, my new blog! Here, I\u0026rsquo;ll be writing posts exploring various topics I find interesting. It\u0026rsquo;s meant as a platform so I can share knowledge with others.\nProgramming and software development will likely be the main focus of this blog, but I\u0026rsquo;ll be discussing anything that I find interesting.\nI don\u0026rsquo;t have a release schedule for these posts. I\u0026rsquo;ll be creating them as I find topics to cover, so make sure to stay tuned!\nSource code cristian-aldea/starlog is the git repository containing the source code for this blog.\nAs of writing, I\u0026rsquo;m using Hugo with the PaperMod theme.\n","permalink":"https://blog.cristianaldea.com/posts/2021/welcome-to-starlog/","summary":"I\u0026rsquo;ll explain what Starlog is and link the source code if anyone wants to check it out!","title":"Welcome to Starlog"}]